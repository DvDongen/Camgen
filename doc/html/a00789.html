<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Camorra: include/Camorra/vector.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Camorra</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">include/Camorra/vector.h File Reference</div>  </div>
</div>
<div class="contents">

<p>vector class template interface and implementation header.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;iterator&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;stdexcept&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00623_source.html">Camgen/rn_strm.h</a>&gt;</code><br/>
</div>
<p><a href="a00789_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00551.html">Camorra::vector&lt; T, N &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size vector class.  <a href="a00551.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00552.html">Camorra::vector&lt; T, 0 &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a47698c9e603cabcb69cc0d270cb08935"></a><!-- doxytag: member="vector.h::operator==" ref="a47698c9e603cabcb69cc0d270cb08935" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a47698c9e603cabcb69cc0d270cb08935">Camorra::operator==</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise equality operator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="adc72340f0ee52d071184a650b8ed1248"></a><!-- doxytag: member="vector.h::operator!=" ref="adc72340f0ee52d071184a650b8ed1248" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#adc72340f0ee52d071184a650b8ed1248">Camorra::operator!=</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise unequality operator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a286489ab8d5284eb8ecd1a1fbf8e3f93"></a><!-- doxytag: member="vector.h::operator&lt;" ref="a286489ab8d5284eb8ecd1a1fbf8e3f93" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a286489ab8d5284eb8ecd1a1fbf8e3f93">Camorra::operator&lt;</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison operator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1aafe7313b947964423f8b8c3822202"></a><!-- doxytag: member="vector.h::operator&gt;" ref="ae1aafe7313b947964423f8b8c3822202" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#ae1aafe7313b947964423f8b8c3822202">Camorra::operator&gt;</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison operator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1af6e68495bf231818e4a5c97f1558d8"></a><!-- doxytag: member="vector.h::operator&lt;=" ref="a1af6e68495bf231818e4a5c97f1558d8" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a1af6e68495bf231818e4a5c97f1558d8">Camorra::operator&lt;=</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison operator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a914daee9c08ed7a0a305a6d365e86ea2"></a><!-- doxytag: member="vector.h::operator&gt;=" ref="a914daee9c08ed7a0a305a6d365e86ea2" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a914daee9c08ed7a0a305a6d365e86ea2">Camorra::operator&gt;=</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison operator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad94b25742d29b03b8e5dfab45ff3590a"></a><!-- doxytag: member="vector.h::operator*" ref="ad94b25742d29b03b8e5dfab45ff3590a" args="(const T &amp;c, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#ad94b25742d29b03b8e5dfab45ff3590a">Camorra::operator*</a> (const T &amp;c, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns p element-wise multiplied by c. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a956bcad04d99e4093c0c211f2655e92a"></a><!-- doxytag: member="vector.h::operator*" ref="a956bcad04d99e4093c0c211f2655e92a" args="(const vector&lt; T, N &gt; &amp;q, const T &amp;c)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a956bcad04d99e4093c0c211f2655e92a">Camorra::operator*</a> (const vector&lt; T, N &gt; &amp;q, const T &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns p element-wise multiplied by c. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a99507ebd843ca2918c767e83499369a5"></a><!-- doxytag: member="vector.h::operator/" ref="a99507ebd843ca2918c767e83499369a5" args="(const vector&lt; T, N &gt; &amp;p, const T &amp;c)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a99507ebd843ca2918c767e83499369a5">Camorra::operator/</a> (const vector&lt; T, N &gt; &amp;p, const T &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns p element-wise divided by c. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a29b2d2d0785dc5ad5b5d4d674814d866"></a><!-- doxytag: member="vector.h::operator*" ref="a29b2d2d0785dc5ad5b5d4d674814d866" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a29b2d2d0785dc5ad5b5d4d674814d866">Camorra::operator*</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns p element-wise multiplied by q. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d73ea3918e9a075f0fcead82a91856a"></a><!-- doxytag: member="vector.h::operator+" ref="a8d73ea3918e9a075f0fcead82a91856a" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a8d73ea3918e9a075f0fcead82a91856a">Camorra::operator+</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element-wise addition of p and q. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afd56ad8af55c4378c6c677ca4f556c91"></a><!-- doxytag: member="vector.h::operator&#45;" ref="afd56ad8af55c4378c6c677ca4f556c91" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#afd56ad8af55c4378c6c677ca4f556c91">Camorra::operator-</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element-wise subtraction of p and q. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aec24b52a12a68e2e3dc789e07f7d95d4"></a><!-- doxytag: member="vector.h::operator&#45;" ref="aec24b52a12a68e2e3dc789e07f7d95d4" args="(const vector&lt; T, N &gt; &amp;p)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#aec24b52a12a68e2e3dc789e07f7d95d4">Camorra::operator-</a> (const vector&lt; T, N &gt; &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the opposite of p. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3fc143234a7df616d5107e41ccd7748b"></a><!-- doxytag: member="vector.h::dot" ref="a3fc143234a7df616d5107e41ccd7748b" args="(const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a3fc143234a7df616d5107e41ccd7748b">Camorra::dot</a> (const vector&lt; T, N &gt; &amp;p, const vector&lt; T, N &gt; &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (Euclidean) inner product of p and q. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9a4680c7143fd053d8ddb55d7dedf0f5"></a><!-- doxytag: member="vector.h::operator&lt;&lt;" ref="a9a4680c7143fd053d8ddb55d7dedf0f5" args="(std::ostream &amp;os, const vector&lt; T, N &gt; &amp;v)" -->
template&lt;class T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00831.html#a9a4680c7143fd053d8ddb55d7dedf0f5">Camorra::operator&lt;&lt;</a> (std::ostream &amp;os, const vector&lt; T, N &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the content of v to the output stream os. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>vector class template interface and implementation header. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Dec 21 2011 00:23:04 for Camorra by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
